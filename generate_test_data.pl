#!/usr/bin/perl
### This script has been coded to automate the process of creating data for the Sphinx4 KeyWordSpottingTest app
### Input data consists of high quality wave files (audiobook parts from librevox) and their subscriptions took from the gutenberg project (recording_name.wav and recording_name.txt respectively, mp3s converted to waves with ffmpeg -i file.mp3 -ar 16000 -ac 1 file.wav)
### This script generates:
### 1) correct results expected by the keyword spotting app (list of newline-separated words in filename corresponding to each wave file), segregated by the number of phonemes (ranges: "4-7","8-11","12-15","16-20") obtained from the cmudict.0.6d file (other words are ignored)
### 2)  phonemes count segregated dictionaries (list of words to spot) generated by most popular words from the transcriptions
### coded by ewilded
use strict;
my %config;
$config{TEST_DATA}='test_data/'; # where to look for the transcriptions and waves (output files also go to that directory) 
$config{CMUDICT_PATH}='cmudict.0.6d';
$config{WORDS_NUMBER}=10; ## how many words have to be placed into *.search files (dictionaries); each number of phonemes should have the same number of words to spot, this number corresponds to the amount of most popular transcription words that will be picked up to be placed into expected *.search dictionaries and expected results, rest will be skipped

die($config{CMUDICT_PATH}. "not found, cannot continue.") if(! -f $config{CMUDICT_PATH});
my @phonemes_ranges=('4-7','8-11','12-15','16-20');
my %cmudict; ## hash to hold the dictionary segregated by the phonemes length
my %result; ## hash containing the whole result for particular recording; less popular words will be excluded from search dictionaries and result files
open(CMUDICT,"<$config{CMUDICT_PATH}");
print "Reading $config{CMUDICT_PATH}...\n";
while(my $row=<CMUDICT>)
{
	chomp($row);
	my @parts=split(/\s+/,$row);
	my $phonemes_count=scalar(@parts)-1;
	my $word=lc($parts[0]); # lowercase
	$word=~s/\(\w+\)//;
	next if($phonemes_count<4||$phonemes_count>20); ## skip words out of range
	$cmudict{'PHONEMES_4-7'}{$word}{COUNT}=0 if($phonemes_count>3&&$phonemes_count<8);
	$cmudict{'PHONEMES_8-11'}{$word}{COUNT}=0 if($phonemes_count>7&&$phonemes_count<12);
	$cmudict{'PHONEMES_12-15'}{$word}{COUNT}=0 if($phonemes_count>11&&$phonemes_count<16);
	$cmudict{'PHONEMES_16-20'}{$word}{COUNT}=0 if($phonemes_count>15&&$phonemes_count<21);
}
print "OK.\n";
close(CMUDICT);

my @wave_files=`ls $config{TEST_DATA}/*wav`;
foreach my $wave_file(@wave_files)
{
	chomp($wave_file);
	my $name=$wave_file;
	$name=~s/\.wav$//i;
	my $transcription="$name.txt";
	if(! -f $transcription)
	{
		print "WARNING: $transcription for $wave_file does not exist, skipping this one.\n";
		next;
	}
	open(TRANSCRIPTION,"<$transcription");
	while(my $row=<TRANSCRIPTION>)
	{
		$row=~s/[^\s\w']//g; ## remove everything not being a space, alphanum and single quote
		my @words=split(/\s+/,$row);
		foreach my $word(@words)
		{
			$word=lc($word); ## lowercase
			my $ph_range='';
			foreach my $curr_ph_range(@phonemes_ranges)
			{
				if($cmudict{"PHONEMES_$curr_ph_range"}{$word} ne undef)
				{
					$ph_range=$curr_ph_range;
					last;
				}
			}	
			next if($ph_range eq ''); ## word unknown to cmudict or out of range
			print "Word: $word,$ph_range\n";
			$cmudict{"PHONEMES_$ph_range"}{$word}{'COUNT'}++; ## increment the occurances number
			$result{$name}{$word}=0 if($result{$name} eq undef||$result{$name}{$word} eq undef);
			$result{$name}{$word}++; ## remember that this word occurs in this file
		}
	}
	close(TRANSCRIPTION);
}

## we have to create separate dictionaries
open(FD1,">$config{TEST_DATA}/words_to_spot.4-7.txt");
open(FD2,">$config{TEST_DATA}/words_to_spot.8-11.txt");
open(FD3,">$config{TEST_DATA}/words_to_spot.12-15.txt");
open(FD4,">$config{TEST_DATA}/words_to_spot.16-20.txt");
## flush older results
`rm -rf $config{TEST_DATA}/*.result.txt`;

for my $ph_range(reverse @phonemes_ranges)
{
	print "Picking up words for phonemes range $ph_range...\n"; 
	my $cnt=0;	
	while($cnt<$config{WORDS_NUMBER})
	{
		$cnt++;
		my $most_frequent_hash='';
		foreach my $result(keys %{$cmudict{"PHONEMES_$ph_range"}})
		{
			if($most_frequent_hash eq '')
			{
				$most_frequent_hash=$result;
			}
			else
			{
				# replace current maximum if something more popular is found
				print "ph_range:$ph_range; result:$result\n";
				$most_frequent_hash=$result if($cmudict{"PHONEMES_$ph_range"}{$result}{COUNT}>$cmudict{"PHONEMES_$ph_range"}{$most_frequent_hash}{COUNT});
			}
		}
		my $w=$most_frequent_hash;
		my $l=length($w);
		print "Most frequent: $most_frequent_hash\n";
		
		print FD1 "$w\n" if($ph_range eq '4-7');
		print FD2 "$w\n" if($ph_range eq '8-11');
		print FD3 "$w\n" if($ph_range eq '12-15');
		print FD4 "$w\n" if($ph_range eq '16-20');
		
		## Building result file
		foreach my $filename(keys %result)
		{
			if($result{$filename}{$w} ne undef)
			{
				open(F,">>$filename.$ph_range.result.txt");
				for(my $i=0;$i<$result{$filename}{$w};$i++)
				{
					print F "$w\n";
				}
				close(F);
			}
		}
		delete $cmudict{"PHONEMES_$ph_range"}{$w}; ### remove the hash entry
	}
}

close(FD1); 
close(FD2);
close(FD3);
close(FD4);
# Create file with test data paths (the only argument for kws_test.jar):
open(F,">$config{TEST_DATA}/filelist.txt");
foreach my $filename(keys %result)
{
	print F "$filename\n";
}
close(F);
print "Test data generated.\n";